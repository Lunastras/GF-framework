using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;
using MEC;
using TMPro;
using UnityEngine;
using System.Diagnostics;

[Serializable]
public class GfxRichTextWriter
{
    public TextMeshProUGUI TextMeshPro
    {
        get { return m_textMeshPro; }
        set
        {
            if (m_textMeshPro) m_textMeshPro.OnPreRenderText -= OnPreRenderText;
            m_textMeshPro = value;
            m_textMeshPro.OnPreRenderText += OnPreRenderText;
        }
    }

    private TransitionRuntimeData m_currentTransitionData;

    public FloatAndInv LetterDelaySeconds;

    public FloatAndInv LetterTranslateSeconds;

    public FloatAndInv SpeedMultiplier = new(1);

    public bool IgnoreWhitespace;

    //public bool StaticVertexData = true;

    public TextWriterTranslation TranslationFadeIn;

    public TextWriterTranslation TranslationFadeOut;

    [SerializeField] protected TextMeshProUGUI m_textMeshPro;

    private FloatAndInv m_writeAllSpeedMultiplier = new(0);

    private bool m_writeAllOnce = false;

    private float m_secondsSinceWriteAll = 0;

    private GfcCoroutineHandle m_textTransitionHandle = default;

    private GfcCoroutineHandle m_textEraseHandle = default;

    const int VERT_COUNT = 4;

    private List<VertexData> m_vertexData = new(32);

    private int m_lastFrameUpdated = 0;

    public GfxRichTextWriter() { }

    public void RefreshValues()
    {
        LetterDelaySeconds.Refresh();
        LetterTranslateSeconds.Refresh();
        SpeedMultiplier.Refresh();
        m_writeAllSpeedMultiplier.Refresh();
    }

    public GfxRichTextWriter(GfxRichTextWriter anObjectToCopy)
    {
        m_textMeshPro = anObjectToCopy.m_textMeshPro;
        LetterDelaySeconds = anObjectToCopy.LetterDelaySeconds;
        LetterTranslateSeconds = anObjectToCopy.LetterTranslateSeconds;
        IgnoreWhitespace = anObjectToCopy.IgnoreWhitespace;
        TranslationFadeIn = anObjectToCopy.TranslationFadeIn;
        TranslationFadeOut = anObjectToCopy.TranslationFadeOut;
    }

    public void SetString(string aString, bool aWriteTextInstant = true)
    {
        m_textMeshPro.SetText(aString);
        if (aWriteTextInstant)
            WriteAllNoTransition(true, true);
    }

    public string GetString() { return m_textMeshPro.text; }

    public int TextLength { get { return m_textMeshPro.textInfo.characterCount; } }

    public bool WritingText() { return m_textEraseHandle.CoroutineIsRunning || m_textTransitionHandle.CoroutineIsRunning; }

    private bool ValidCharacter(char aChar) { return !IgnoreWhitespace || (aChar != ' ' && aChar != '\n' && aChar != '\t'); }//not an exhaustive list

    public CoroutineHandle FinishTranslation(float aSpeedMultiplier = 1)
    {
        if (!m_writeAllOnce && m_textTransitionHandle.CoroutineIsRunning)
        {
            m_writeAllSpeedMultiplier.Value = aSpeedMultiplier;
            m_secondsSinceWriteAll = 0;
        }

        m_writeAllOnce = m_textTransitionHandle.CoroutineIsRunning;
        return m_textTransitionHandle;
    }

    public CoroutineHandle WriteText(string aString, float aSpeedMultiplier = 1) { SetString(aString, true); return WriteStringAnimation(true, aSpeedMultiplier); }

    public void RemoveText() { SetString(null); }

    public CoroutineHandle EraseText(float aSpeedMultiplier = 1) { return m_textEraseHandle.RunCoroutineIfNotRunning(_EraseText(aSpeedMultiplier)); }

    private IEnumerator<float> _EraseText(float aSpeedMultiplier = 1)
    {
        m_textTransitionHandle.KillCoroutine();

        yield return Timing.WaitUntilDone(WriteStringAnimation(false, aSpeedMultiplier), false);
        m_textMeshPro.text = "";

        m_textEraseHandle.Finished();
    }

    public void WriteAllNoTransition(bool aIgnoreActiveState = false, bool aForceTextReparsing = false)
    {
        m_textEraseHandle.KillCoroutine();
        m_textTransitionHandle.KillCoroutine();
        m_textMeshPro.ForceMeshUpdate(aIgnoreActiveState, aForceTextReparsing);
    }

    private CoroutineHandle WriteStringAnimation(bool aFadeIn, float aSpeedMultiplier = 1) { return m_textTransitionHandle.RunCoroutineIfNotRunning(_ExecuteCharacterTransition(aFadeIn, aSpeedMultiplier)); }

    public virtual void ApplyStaticEffects(TMP_TextInfo aTextInfo)
    {
        TMP_CharacterInfo[] charsInfo = aTextInfo.characterInfo;
    }

    [System.Serializable]
    public struct FloatAndInv
    {
        public float Value
        {
            get { return m_value; }
            set
            {
                m_value = value;
                m_inverse = value.SafeInverse();
            }
        }

        public FloatAndInv(float aValue = 0)
        {
            m_value = aValue;
            m_inverse = aValue.SafeInverse();
        }

        public void Refresh() { Value = m_value; }

        public readonly float Inverse { get { return m_inverse; } }

        public static implicit operator float(FloatAndInv d) => d.Value;

        [SerializeField] private float m_value;
        private float m_inverse;
    }

    private TMP_VertexDataUpdateFlags ApplyTransitionEffectToText(bool aFadeIn, bool anEarlyBreak, ref int lastFinishedIndex, ref int validIndexOfLastFinished, float secondsSinceStart)
    {
        int validCharactersCount = 0;
        TMP_TextInfo aTextInfo = m_textMeshPro.textInfo;
        var charactersInfo = aTextInfo.characterInfo;
        int characterCount = aTextInfo.characterCount;

        TMP_VertexDataUpdateFlags vertexUpdateFlag = TMP_VertexDataUpdateFlags.None;

        for (int i = lastFinishedIndex + 1; i < characterCount; i++)
        {
            TMP_CharacterInfo charInfo = charactersInfo[i];
            if (ValidCharacter(charInfo.character))// Skips spaces
            {
                validCharactersCount++;
                int validCharacterIndex = validIndexOfLastFinished + validCharactersCount;
                float auxSecondsSinceStart = secondsSinceStart - validCharacterIndex * LetterDelaySeconds * SpeedMultiplier.Inverse * m_writeAllSpeedMultiplier.Inverse;
                auxSecondsSinceStart.MaxSelf(m_secondsSinceWriteAll);

                if (anEarlyBreak && auxSecondsSinceStart <= 0)
                    break;

                float timeCoef = (SpeedMultiplier * auxSecondsSinceStart * LetterTranslateSeconds.Inverse * m_writeAllSpeedMultiplier).Min(1);
                float timeCoefAux = aFadeIn ? timeCoef : 1.0f - timeCoef;

                vertexUpdateFlag |= ApplyTransitionEffectToChar(aFadeIn, timeCoefAux, validCharacterIndex, aTextInfo, charInfo, m_vertexData[validCharacterIndex]);

                if (timeCoef >= 1)
                {
                    lastFinishedIndex = i;
                    validCharactersCount = 0;
                    validIndexOfLastFinished = validCharacterIndex;
                }
            }
        }

        return vertexUpdateFlag;
    }

    private TMP_VertexDataUpdateFlags ApplyTransitionEffectToChar(bool aFadeIn, float aTimeCoef, int aValidCharacterIndex, TMP_TextInfo aTextInfo, TMP_CharacterInfo aCharacterInfo, VertexData aOriginalVertexData)
    {
        TextWriterTranslation translation = aFadeIn ? TranslationFadeIn : TranslationFadeOut;

        int vertexIndexStart = aCharacterInfo.vertexIndex;
        float coef = aValidCharacterIndex % 2 == 0 ? 1 : -1;
        coef = 1;

        float lerpProgress = translation.TransitionCurve.Evaluate(aTimeCoef).Clamp(0, 1);

        Vector3 globalPositionOffset = translation.GlobalPosition * (coef * (1.0f - lerpProgress));
        Vector3 localPositionOffset = translation.LocalPosition * (coef * (1.0f - lerpProgress));

        Vector3 currentLocalScale = translation.LocalScale.Lerp(new Vector3(1, 1, 1), lerpProgress);
        Vector3 currentGlobalScale = translation.GlobalScale.Lerp(new Vector3(1, 1, 1), lerpProgress);

        int materialIndex = aCharacterInfo.materialReferenceIndex;
        Color32[] vertColors = aTextInfo.meshInfo[materialIndex].colors32;
        Vector3[] vertPositions = aTextInfo.meshInfo[materialIndex].vertices;

        Quaternion localRotation = Quaternion.AngleAxis(translation.LocalRotationZ.Lerp(0, lerpProgress), Vector3.forward);

        for (int j = 0; j < VERT_COUNT; ++j)
        {
            int vertexIndex = vertexIndexStart + j;
            Vector3 currentPosition = aOriginalVertexData.ModelPositions[j];

            //apply local transform
            GfcTools.Mult(ref currentPosition, currentLocalScale);
            currentPosition = localRotation * currentPosition;
            GfcTools.Add(ref currentPosition, localPositionOffset);

            //model/local to world
            currentPosition = aOriginalVertexData.LocalRotation * currentPosition;
            GfcTools.Add(ref currentPosition, aOriginalVertexData.Center);

            //apply global transform
            GfcTools.Mult(ref currentPosition, currentGlobalScale);
            GfcTools.Add(ref currentPosition, globalPositionOffset);

            Color32 transitionColor = GfxUiTools.BlendColors(aOriginalVertexData.Colors[j], translation.Color, translation.ColorBlendMode);

            vertPositions[vertexIndex] = currentPosition;
            vertColors[vertexIndex] = Color32.Lerp(transitionColor, aOriginalVertexData.Colors[j], lerpProgress);
        }

        return TMP_VertexDataUpdateFlags.Colors32 | TMP_VertexDataUpdateFlags.Vertices;
    }

    private void OnPreRenderText(TMP_TextInfo aTmpInfo)
    {
        UpdateOriginalVertexDataBuffer();

        m_lastFrameUpdated = Time.frameCount;
        UnityEngine.Debug.Log("Pre render callback");
    }

    private IEnumerator<float> _ExecuteCharacterTransition(bool aFadeIn, float aSpeedMultiplier = 1)
    {
        SpeedMultiplier.Value = aSpeedMultiplier;

        if (TextLength == 0)
            yield break;

        m_textMeshPro.ForceMeshUpdate();

        float secondsSinceStart = 0;

        m_writeAllOnce = false;
        m_secondsSinceWriteAll = 0;
        m_writeAllSpeedMultiplier.Value = 1;

        UpdateOriginalVertexDataBuffer();

        TMP_VertexDataUpdateFlags vertexUpdateFlag = TMP_VertexDataUpdateFlags.None;

        bool firstIteration = true;
        int lastFinishedIndex = -1;
        int characterCount = TextLength;
        int lastIndex = characterCount - 1;
        int validIndexOfLastFinished = -1;

        while (lastFinishedIndex < lastIndex)
        {
            vertexUpdateFlag |= ApplyTransitionEffectToText(aFadeIn, !firstIteration, ref lastFinishedIndex, ref validIndexOfLastFinished, secondsSinceStart);

            m_textMeshPro.UpdateVertexData(vertexUpdateFlag);
            vertexUpdateFlag = TMP_VertexDataUpdateFlags.None;

            float timeOfWaitStart = Time.time;
            yield return Timing.WaitForOneFrame;

            float elapsedSeconds = Time.time - timeOfWaitStart;
            if (m_writeAllOnce) m_secondsSinceWriteAll += elapsedSeconds;
            secondsSinceStart += elapsedSeconds;
            firstIteration = false;
        }

        UnityEngine.Debug.Log("Finished routine");

        m_textTransitionHandle.Finished();
    }

    //update the the buffer data with the new original vertex data used for the transition lerping
    private void UpdateOriginalVertexDataBuffer()
    {
        TMP_TextInfo aTextInfo = m_textMeshPro.textInfo;
        TMP_CharacterInfo[] charsInfo = aTextInfo.characterInfo;
        int length = TextLength;

        ApplyStaticEffects(aTextInfo);

        m_vertexData.Clear();

        for (int i = 0; i < length; i++)
        {
            if (ValidCharacter(charsInfo[i].character))
            {
                int vertexIndexStart = charsInfo[i].vertexIndex;
                int materialIndex = charsInfo[i].materialReferenceIndex;

                Color32[] vertColors = aTextInfo.meshInfo[materialIndex].colors32;
                Vector3[] vertPositions = aTextInfo.meshInfo[materialIndex].vertices;

                Vector3 center = Vector3.zero;

                Vector2 vert0To3 = vertPositions[vertexIndexStart + 0] + vertPositions[vertexIndexStart + 3];
                float rotationZDeg = Mathf.Rad2Deg * MathF.Atan2(vert0To3.y, vert0To3.x);

                Quaternion UndoLocalRotation = Quaternion.AngleAxis(-rotationZDeg, Vector3.forward);

                VertexData data = default;
                for (int j = 0; j < VERT_COUNT; ++j)
                {
                    int vertexIndex = vertexIndexStart + j;
                    data.Colors[j] = vertColors[vertexIndex];
                    data.WorldPositions[j] = vertPositions[vertexIndex];
                    GfcTools.Add(ref center, vertPositions[vertexIndex]);
                }

                GfcTools.Mult(ref center, 0.25f); //average of the positions, same as dividing by 4

                for (int j = 0; j < VERT_COUNT; ++j)
                {
                    int vertexIndex = vertexIndexStart + j;
                    Vector3 modelPosition = vertPositions[vertexIndex];

                    //world to model
                    GfcTools.Minus(ref modelPosition, center);
                    modelPosition = UndoLocalRotation * modelPosition;

                    data.ModelPositions[j] = modelPosition;
                }

                data.Center = center;
                data.LocalZRotationDeg = rotationZDeg;
                data.LocalRotation = Quaternion.AngleAxis(rotationZDeg, Vector3.forward);

                m_vertexData.Add(data);
            }
        }
    }
}

[Serializable]
public struct TextWriterTranslation
{
    public Vector3 GlobalPosition;

    public Vector3 LocalPosition;

    public Vector3 GlobalScale;

    public Vector3 LocalScale;

    public AnimationCurve TransitionCurve;

    public Color32 Color;

    public ColorBlendMode ColorBlendMode;

    public float LocalRotationZ;
}

internal struct VertexData
{
    public Vector4<Color32> Colors;
    public Vector4<Vector3> WorldPositions;
    public Vector4<Vector3> ModelPositions;
    public Quaternion LocalRotation;
    public Vector3 Center;
    public float LocalZRotationDeg;
}

internal struct TransitionRuntimeData
{
    public int ValidIndexOfLastFinishedChar;
    public int LastFinishedIndex;
    public bool FadeIn;
}





















using System.Collections;
using System.Collections.Generic;
using MEC;
using TMPro;
using UnityEngine;
using UnityEngine.Assertions;

[System.Serializable]
public class GfxRichTextWriter
{
    public TextMeshProUGUI TextMeshPro
    {
        get { return m_textMeshPro; }
        set
        {
            if (m_textMeshPro) m_textMeshPro.OnPreRenderText -= OnPreRenderText;
            m_textMeshPro = value;
            m_textMeshPro.OnPreRenderText += OnPreRenderText;
        }
    }

    private TransitionRuntimeData m_transitionData;

    public FloatAndInv LetterDelaySeconds;

    public FloatAndInv LetterTranslateSeconds;

    public FloatAndInv SpeedMultiplier = new(1);

    public bool IgnoreWhitespace;

    //public bool StaticVertexData = true;

    public TextWriterTranslation TranslationFadeIn;

    public TextWriterTranslation TranslationFadeOut;

    [SerializeField] protected TextMeshProUGUI m_textMeshPro;

    private FloatAndInv m_writeAllSpeedMultiplier = new(0);

    private bool m_writeAllOnce = false;

    private float m_secondsSinceWriteAll = 0;

    private GfcCoroutineHandle m_textTransitionHandle = default;

    private GfcCoroutineHandle m_textEraseHandle = default;

    const int VERT_COUNT = 4;

    private List<VertexData> m_vertexData = new(32);

    private int m_lastFrameUpdated = 0;

    public GfxRichTextWriter() { }

    public void RefreshValues()
    {
        LetterDelaySeconds.Refresh();
        LetterTranslateSeconds.Refresh();
        SpeedMultiplier.Refresh();
        m_writeAllSpeedMultiplier.Refresh();
    }

    public GfxRichTextWriter(GfxRichTextWriter anObjectToCopy)
    {
        m_textMeshPro = anObjectToCopy.m_textMeshPro;
        LetterDelaySeconds = anObjectToCopy.LetterDelaySeconds;
        LetterTranslateSeconds = anObjectToCopy.LetterTranslateSeconds;
        IgnoreWhitespace = anObjectToCopy.IgnoreWhitespace;
        TranslationFadeIn = anObjectToCopy.TranslationFadeIn;
        TranslationFadeOut = anObjectToCopy.TranslationFadeOut;
    }

    public void SetString(string aString, bool aWriteTextInstant = true)
    {
        m_textMeshPro.SetText(aString);
        if (aWriteTextInstant)
            WriteAllNoTransition(true, true);
    }

    public string GetString() { return m_textMeshPro.text; }

    public int TextLength { get { return m_textMeshPro.textInfo.characterCount; } }

    public bool WritingText()
    {
        bool ret = m_textEraseHandle.CoroutineIsRunning || m_textTransitionHandle.CoroutineIsRunning;
        //if (ret) Debug.Log("Erase: " + m_textEraseHandle.CoroutineIsRunning + " transition: " + m_textTransitionHandle.CoroutineIsRunning);
        return ret;
    }

    private bool ValidCharacter(char aChar) { return !IgnoreWhitespace || (aChar != ' ' && aChar != '\n' && aChar != '\t'); }//not an exhaustive list

    public CoroutineHandle FinishTranslation(float aSpeedMultiplier = 1)
    {
        if (!m_writeAllOnce && m_textTransitionHandle.CoroutineIsRunning)
        {
            m_writeAllSpeedMultiplier.Value = aSpeedMultiplier;
            m_secondsSinceWriteAll = 0;
        }

        m_writeAllOnce = m_textTransitionHandle.CoroutineIsRunning;
        return m_textTransitionHandle;
    }

    public CoroutineHandle WriteText(string aString, float aSpeedMultiplier = 1) { SetString(aString, true); return WriteStringAnimation(true, aSpeedMultiplier); }

    public void RemoveText() { SetString(null); }

    public CoroutineHandle EraseText(float aSpeedMultiplier = 1) { return m_textEraseHandle.RunCoroutineIfNotRunning(_EraseText(aSpeedMultiplier)); }

    private IEnumerator<float> _EraseText(float aSpeedMultiplier = 1)
    {
        m_textTransitionHandle.KillCoroutine();

        Debug.Log("Erase start");
        yield return Timing.WaitUntilDone(WriteStringAnimation(false, aSpeedMultiplier), false);
        m_textMeshPro.text = "";
        Debug.Log("Erase END");

        m_textEraseHandle.Finished();
        m_textTransitionHandle.Finished();
    }

    public void WriteAllNoTransition(bool aIgnoreActiveState = false, bool aForceTextReparsing = false)
    {
        m_textEraseHandle.KillCoroutine();
        m_textTransitionHandle.KillCoroutine();
        m_textMeshPro.ForceMeshUpdate(aIgnoreActiveState, aForceTextReparsing);
    }

    private CoroutineHandle WriteStringAnimation(bool aFadeIn, float aSpeedMultiplier = 1)
    {
        Debug.Assert(!m_textTransitionHandle.CoroutineIsRunning);
        return m_textTransitionHandle.RunCoroutineIfNotRunning(_ExecuteCharacterTransition(aFadeIn, aSpeedMultiplier));
    }

    public virtual void ApplyStaticEffects(TMP_TextInfo aTextInfo)
    {
        TMP_CharacterInfo[] charsInfo = aTextInfo.characterInfo;
    }

    [System.Serializable]
    public struct FloatAndInv
    {
        public float Value
        {
            readonly get { return m_value; }
            set
            {
                m_value = value;
                m_inverse = value.SafeInverse();
            }
        }

        public FloatAndInv(float aValue = 0)
        {
            m_value = aValue;
            m_inverse = aValue.SafeInverse();
        }

        public void Refresh() { Value = m_value; }

        public readonly float Inverse { get { return m_inverse; } }

        public static implicit operator float(FloatAndInv d) => d.Value;

        [SerializeField] private float m_value;
        private float m_inverse;
    }

    private TMP_VertexDataUpdateFlags ApplyTransitionEffectToText(bool aParseEntireString)
    {
        int validCharactersCount = 0;
        TMP_TextInfo aTextInfo = m_textMeshPro.textInfo;
        var charactersInfo = aTextInfo.characterInfo;
        int characterCount = aTextInfo.characterCount;

        TMP_VertexDataUpdateFlags vertexUpdateFlag = TMP_VertexDataUpdateFlags.None;

        if (aParseEntireString)
        {
            m_transitionData.ValidIndexOfLastFinishedChar = -1;
            m_transitionData.LastFinishedIndex = -1;
        }

        for (int i = m_transitionData.LastFinishedIndex + 1; i < characterCount; i++)
        {
            TMP_CharacterInfo charInfo = charactersInfo[i];
            if (ValidCharacter(charInfo.character))// Skips spaces
            {
                validCharactersCount++;
                int validCharacterIndex = m_transitionData.ValidIndexOfLastFinishedChar + validCharactersCount;
                float auxSecondsSinceStart = m_transitionData.SecondsSinceStart - validCharacterIndex * LetterDelaySeconds * SpeedMultiplier.Inverse * m_writeAllSpeedMultiplier.Inverse;
                auxSecondsSinceStart.MaxSelf(m_secondsSinceWriteAll);

                if (!aParseEntireString && auxSecondsSinceStart <= 0)
                    break;

                float timeCoef = (SpeedMultiplier * auxSecondsSinceStart * LetterTranslateSeconds.Inverse * m_writeAllSpeedMultiplier).Min(1);
                float timeCoefAux = m_transitionData.FadeIn ? timeCoef : 1.0f - timeCoef;

                vertexUpdateFlag |= ApplyTransitionEffectToChar(m_transitionData.FadeIn, timeCoefAux, validCharacterIndex, aTextInfo, charInfo, m_vertexData[validCharacterIndex]);

                if (timeCoef >= 1)
                {
                    validCharactersCount = 0;
                    m_transitionData.LastFinishedIndex = i;
                    m_transitionData.ValidIndexOfLastFinishedChar = validCharacterIndex;
                }
            }
        }

        return vertexUpdateFlag;
    }

    private TMP_VertexDataUpdateFlags ApplyTransitionEffectToChar(bool aFadeIn, float aTimeCoef, int aValidCharacterIndex, TMP_TextInfo aTextInfo, TMP_CharacterInfo aCharacterInfo, VertexData aOriginalVertexData)
    {
        TextWriterTranslation translation = aFadeIn ? TranslationFadeIn : TranslationFadeOut;

        int vertexIndexStart = aCharacterInfo.vertexIndex;
        float coef = aValidCharacterIndex % 2 == 0 ? 1 : -1;
        coef = 1;

        float lerpProgress = translation.TransitionCurve.Evaluate(aTimeCoef).Clamp(0, 1);

        Vector3 globalPositionOffset = translation.GlobalPosition * (coef * (1.0f - lerpProgress));
        Vector3 localPositionOffset = translation.LocalPosition * (coef * (1.0f - lerpProgress));

        Vector3 currentLocalScale = translation.LocalScale.Lerp(new Vector3(1, 1, 1), lerpProgress);
        Vector3 currentGlobalScale = translation.GlobalScale.Lerp(new Vector3(1, 1, 1), lerpProgress);

        int materialIndex = aCharacterInfo.materialReferenceIndex;
        Color32[] vertColors = aTextInfo.meshInfo[materialIndex].colors32;
        Vector3[] vertPositions = aTextInfo.meshInfo[materialIndex].vertices;

        Quaternion localRotation = Quaternion.AngleAxis(translation.LocalRotationZ.Lerp(0, lerpProgress), Vector3.forward);

        for (int j = 0; j < VERT_COUNT; ++j)
        {
            int vertexIndex = vertexIndexStart + j;
            Vector3 currentPosition = aOriginalVertexData.ModelPositions[j];

            //apply local transform
            GfcTools.Mult(ref currentPosition, currentLocalScale);
            currentPosition = localRotation * currentPosition;
            GfcTools.Add(ref currentPosition, localPositionOffset);

            //model/local to world
            currentPosition = aOriginalVertexData.LocalRotation * currentPosition;
            GfcTools.Add(ref currentPosition, aOriginalVertexData.Center);

            //apply global transform
            GfcTools.Mult(ref currentPosition, currentGlobalScale);
            GfcTools.Add(ref currentPosition, globalPositionOffset);

            Color32 transitionColor = GfxUiTools.BlendColors(aOriginalVertexData.Colors[j], translation.Color, translation.ColorBlendMode);

            vertPositions[vertexIndex] = currentPosition;
            vertColors[vertexIndex] = Color32.Lerp(transitionColor, aOriginalVertexData.Colors[j], lerpProgress);
        }

        return TMP_VertexDataUpdateFlags.Colors32 | TMP_VertexDataUpdateFlags.Vertices;
    }

    private void OnPreRenderText(TMP_TextInfo aTmpInfo)
    {
        return;
        if (WritingText())
        {
            UpdateOriginalVertexDataBuffer();
            m_textMeshPro.UpdateVertexData(ApplyTransitionEffectToText(true));

            UnityEngine.Debug.Log("Pre render callback");
        }
        else
        {
            UnityEngine.Debug.Log("I was called, but I ain't executing anything");
        }
    }

    private IEnumerator<float> _ExecuteCharacterTransition(bool aFadeIn, float aSpeedMultiplier = 1)
    {
        SpeedMultiplier.Value = aSpeedMultiplier;

        m_textMeshPro.ForceMeshUpdate();
        UpdateOriginalVertexDataBuffer();

        m_writeAllOnce = false;
        m_secondsSinceWriteAll = 0;
        m_writeAllSpeedMultiplier.Value = 1;

        m_transitionData.FadeIn = aFadeIn;
        m_transitionData.SecondsSinceStart = 0;

        TMP_VertexDataUpdateFlags vertexUpdateFlag = TMP_VertexDataUpdateFlags.None;

        bool firstIteration = true;
        int lastIndex = TextLength - 1;

        while (m_transitionData.LastFinishedIndex < lastIndex)
        {
            vertexUpdateFlag |= ApplyTransitionEffectToText(firstIteration);

            m_textMeshPro.UpdateVertexData(vertexUpdateFlag);
            vertexUpdateFlag = TMP_VertexDataUpdateFlags.None;

            float timeOfWaitStart = Time.time;
            yield return Timing.WaitForOneFrame;

            float elapsedSeconds = Time.time - timeOfWaitStart;
            if (m_writeAllOnce) m_secondsSinceWriteAll += elapsedSeconds;
            m_transitionData.SecondsSinceStart += elapsedSeconds;
            firstIteration = false;
        }

        Debug.Log("Finished transition");

        m_textTransitionHandle.Finished();
    }

    //update the the buffer data with the new original vertex data used for the transition lerping
    private void UpdateOriginalVertexDataBuffer()
    {
        TMP_TextInfo aTextInfo = m_textMeshPro.textInfo;
        TMP_CharacterInfo[] charsInfo = aTextInfo.characterInfo;
        int length = TextLength;

        ApplyStaticEffects(aTextInfo);

        m_vertexData.Clear();

        for (int i = 0; i < length; i++)
        {
            if (ValidCharacter(charsInfo[i].character))
            {
                int vertexIndexStart = charsInfo[i].vertexIndex;
                int materialIndex = charsInfo[i].materialReferenceIndex;

                Color32[] vertColors = aTextInfo.meshInfo[materialIndex].colors32;
                Vector3[] vertPositions = aTextInfo.meshInfo[materialIndex].vertices;

                Vector3 center = Vector3.zero;

                Vector2 vert0To3 = vertPositions[vertexIndexStart + 0] + vertPositions[vertexIndexStart + 3];
                float rotationZDeg = Mathf.Rad2Deg * System.MathF.Atan2(vert0To3.y, vert0To3.x);

                Quaternion UndoLocalRotation = Quaternion.AngleAxis(-rotationZDeg, Vector3.forward);

                VertexData data = default;
                for (int j = 0; j < VERT_COUNT; ++j)
                {
                    int vertexIndex = vertexIndexStart + j;
                    data.Colors[j] = vertColors[vertexIndex];
                    data.WorldPositions[j] = vertPositions[vertexIndex];
                    GfcTools.Add(ref center, vertPositions[vertexIndex]);
                }

                GfcTools.Mult(ref center, 0.25f); //average of the positions, same as dividing by 4

                for (int j = 0; j < VERT_COUNT; ++j)
                {
                    int vertexIndex = vertexIndexStart + j;
                    Vector3 modelPosition = vertPositions[vertexIndex];

                    //world to model
                    GfcTools.Minus(ref modelPosition, center);
                    modelPosition = UndoLocalRotation * modelPosition;

                    data.ModelPositions[j] = modelPosition;
                }

                data.Center = center;
                data.LocalZRotationDeg = rotationZDeg;
                data.LocalRotation = Quaternion.AngleAxis(rotationZDeg, Vector3.forward);

                m_vertexData.Add(data);
            }
        }
    }
}

[System.Serializable]
public struct TextWriterTranslation
{
    public Vector3 GlobalPosition;

    public Vector3 LocalPosition;

    public Vector3 GlobalScale;

    public Vector3 LocalScale;

    public AnimationCurve TransitionCurve;

    public Color32 Color;

    public ColorBlendMode ColorBlendMode;

    public float LocalRotationZ;
}

internal struct VertexData
{
    public Vector4<Color32> Colors;
    public Vector4<Vector3> WorldPositions;
    public Vector4<Vector3> ModelPositions;
    public Quaternion LocalRotation;
    public Vector3 Center;
    public float LocalZRotationDeg;
}

